{
  "id": "anicrush",
  "name": "AniCrush",
  "description": "AniCrush streaming provider (sub & dub) for Seanime",
  "version": "1.0.2",
  "author": "JayGxnzalez",
  "type": "onlinestream-provider",
  "language": "javascript",
  "lang": "en",
  "payload": "\\\n/// <reference path=\"./online-streaming-provider.d.ts\" />\n\nclass Provider {\n  private api = \"https://api.anicrush.to\";\n  private base = \"https://anicrush.to\";\n  private defaultServer = 4;\n\n  getSettings(): Settings {\n    return {\n      episodeServers: [\"AniCrush Server\"],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    try {\n      const q = encodeURIComponent(query.query);\n      const url = `${this.api}/shared/v2/movie/list?keyword=${q}&limit=24&page=1`;\n\n      const data = await this._fetchJSON(url);\n      const movies = data?.result?.movies ?? data?.result ?? data?.movies ?? [];\n\n      if (!Array.isArray(movies) || movies.length === 0) return [];\n\n      const lang: SubOrDub = query.dub ? \"dub\" : \"sub\";\n\n      return movies.map((m: any) => ({\n        id: `${m.id}/${lang}`,\n        title: m.name_english || m.name,\n        url: `${this.base}/watch/${m.slug}.${m.id}`,\n        subOrDub: lang,\n      }));\n    } catch (e: any) {\n      console.error(\"[search] error:\", e?.message ?? e);\n      return [];\n    }\n  }\n\n  async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n    try {\n      const [movieId, langPart] = id.split(\"/\");\n      const lang: \"dub\" | \"sub\" = (langPart === \"dub\" || langPart === \"sub\") ? (langPart as any) : \"sub\";\n\n      const url = `${this.api}/shared/v2/episode/list?_movieId=${movieId}`;\n      const data = await this._fetchJSON(url);\n\n      const episodesArr =\n        data?.result?.episodes ??\n        data?.result?.data ??\n        data?.result ??\n        data?.episodes ??\n        [];\n\n      if (!Array.isArray(episodesArr) || episodesArr.length === 0) {\n        console.error(\"[findEpisodes] no episodes found for\", movieId, \"raw:\", JSON.stringify(data, null, 2));\n        return [];\n      }\n\n      return episodesArr.map((ep: any) => ({\n        id: `${movieId}/${lang}/${(ep.number ?? ep.episode ?? ep.id ?? 0)}`,\n        number: ep.number ?? ep.episode ?? ep.id ?? 0,\n        title: ep.title ? String(ep.title) : `Episode ${ep.number ?? ep.episode ?? ep.id ?? 0}`,\n        url: `${this.api}/shared/v2/episode/sources?_movieId=${movieId}&ep=${ep.number ?? ep.episode ?? ep.id ?? 0}&sv=${this.defaultServer}&sc=${lang}`,\n      }));\n    } catch (e: any) {\n      console.error(\"[findEpisodes] error:\", e?.message ?? e);\n      return [];\n    }\n  }\n\n  async findEpisodeServer(episode: EpisodeDetails, _server: string = \"AniCrush Server\"): Promise<EpisodeServer> {\n    try {\n      const data = await this._fetchJSON(episode.url);\n\n      const root = data?.result ?? data?.data ?? data;\n      const sources = root?.sources ?? root?.data?.sources ?? [];\n      const tracks = root?.tracks ?? root?.data?.tracks ?? [];\n\n      if (!Array.isArray(sources) || sources.length === 0) {\n        throw new Error(\"No video sources in response\");\n      }\n\n      const videoSources: VideoSource[] = sources\n        .map((s: any) => ({\n          quality: s.label || s.quality || \"auto\",\n          url: s.file || s.url,\n          type: s.type || (String(s.file || s.url).includes(\".m3u8\") ? \"m3u8\" : \"mp4\"),\n          subtitles: [],\n        }))\n        .filter((v: any) => !!v.url);\n\n      // Try attach English subs\n      const eng = Array.isArray(tracks)\n        ? tracks.find((t: any) => (t.kind === \"captions\" || t.kind === \"subtitles\") && /english/i.test(t.label || \"\"))\n        : null;\n      if (eng?.file) {\n        for (const vs of videoSources) {\n          vs.subtitles = [{ url: eng.file, lang: eng.label || \"English\" }];\n        }\n      }\n\n      return {\n        provider: \"anicrush\",\n        server: _server,\n        headers: {\n          \"Accept\": \"application/json, text/plain, */*\",\n          \"Origin\": this.base,\n          \"Referer\": `${this.base}/`,\n          \"User-Agent\": \"Mozilla/5.0\",\n          \"x-site\": \"anicrush\",\n        },\n        videoSources,\n      };\n    } catch (e: any) {\n      console.error(\"[findEpisodeServer] error:\", e?.message ?? e);\n      return {\n        provider: \"anicrush\",\n        server: _server,\n        headers: {},\n        videoSources: [],\n      };\n    }\n  }\n\n  private async _fetchJSON(url: string): Promise<any> {\n    const res = await fetch(url, {\n      headers: {\n        \"Accept\": \"application/json, text/plain, */*\",\n        \"Origin\": this.base,\n        \"Referer\": `${this.base}/`,\n        \"User-Agent\": \"Mozilla/5.0\",\n        \"x-site\": \"anicrush\",\n      },\n    });\n    return await res.json();\n  }\n}\n"
}