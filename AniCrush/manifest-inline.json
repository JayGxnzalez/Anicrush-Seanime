{
  "id": "anicrush",
  "name": "AniCrush",
  "description": "AniCrush streaming provider (sub & dub) for Seanime",
  "version": "1.6.6",
  "author": "JayGxnzalez",
  "type": "onlinestream-provider",
  "language": "javascript",
  "payload": "class Provider {\\n  constructor() {\\n    this.api = \\\"https://api.anicrush.to\\\";\\n    this.base = \\\"https://anicrush.to\\\";\\n    this.availableServers = [4, 1, 3, 5, 6];\\n    \\n    this.headers = {\\n      \\\"Referer\\\": \\\"https://anicrush.to/\\\",\\n      \\\"User-Agent\\\": \\\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\\\"\\n    };\\n  }\\n\\n  getSettings() {\\n    return {\\n      episodeServers: [\\\"AniCrush Server\\\"],\\n      supportsDub: true,\\n    };\\n  }\\n\\n  async search(query) {\\n    try {\\n      const originalQuery = query.query;\\n      const searchTerms = [];\\n      \\n      searchTerms.push(originalQuery.toLowerCase());\\n      \\n      if (originalQuery !== originalQuery.toLowerCase()) {\\n        searchTerms.push(originalQuery);\\n      }\\n      \\n      const lowerQuery = originalQuery.toLowerCase();\\n      \\n      const suffixesToRemove = [\\n        \\\" the animation\\\",\\n        \\\" (tv)\\\",\\n        \\\" season 1\\\", \\\" season 2\\\", \\\" season 3\\\", \\\" season 4\\\", \\\" season 5\\\",\\n        \\\" s1\\\", \\\" s2\\\", \\\" s3\\\", \\\" s4\\\", \\\" s5\\\",\\n        \\\" part 1\\\", \\\" part 2\\\", \\\" part 3\\\",\\n        \\\" cour 1\\\", \\\" cour 2\\\"\\n      ];\\n      \\n      for (const suffix of suffixesToRemove) {\\n        if (lowerQuery.includes(suffix)) {\\n          const withoutSuffix = lowerQuery.replace(suffix, \\\"\\\").trim();\\n          if (withoutSuffix && !searchTerms.includes(withoutSuffix)) {\\n            searchTerms.push(withoutSuffix);\\n          }\\n        }\\n      }\\n      \\n      for (const searchTerm of searchTerms) {\\n        try {\\n          console.log(\\\"[search] Trying search term: \\\" + searchTerm);\\n          \\n          const q = encodeURIComponent(searchTerm);\\n          const searchUrl = \\\"https://api.anicrush.to/shared/v2/movie/list?keyword=\\\" + q + \\\"&limit=24&page=1\\\";\\n          const searchResponse = await this._fetchJSON(searchUrl);\\n          \\n          if (searchResponse.data && searchResponse.data.length > 0) {\\n            console.log(\\\"[search] Found \\\" + searchResponse.data.length + \\\" results for: \\\" + searchTerm);\\n            \\n            const results = searchResponse.data.map(item => ({\\n              id: item._id,\\n              title: item.title,\\n              url: \\\"https://anicrush.to/watch/\\\" + item.slug,\\n              subOrDub: query.dubbed ? \\\"dub\\\" : \\\"sub\\\"\\n            }));\\n            \\n            return results;\\n          } else {\\n            console.log(\\\"[search] No results for: \\\" + searchTerm);\\n          }\\n        } catch (error) {\\n          console.log(\\\"[search] Error with term \\\" + searchTerm + \\\": \\\" + error.message);\\n          continue;\\n        }\\n      }\\n      \\n      throw new Error(\\\"No results found for any search variation of: \\\" + originalQuery);\\n      \\n    } catch (error) {\\n      console.error(\\\"[search] error: \\\" + error.message);\\n      throw new Error(error.message);\\n    }\\n  }\\n\\n  async findEpisodes(id) {\\n    try {\\n      const idParts = id.split(\\\"/\\\");\\n      const movieId = idParts[0];\\n      const langPart = idParts[1];\\n      const lang = (langPart === \\\"dub\\\" || langPart === \\\"sub\\\") ? langPart : \\\"sub\\\";\\n\\n      if (!movieId || movieId.trim().length === 0) {\\n        throw new Error(\\\"Invalid movieId\\\");\\n      }\\n\\n      if (/^\\\\d+$/.test(movieId)) {\\n        throw new Error(\\\"Received numeric ID which is not supported by AniCrush API\\\");\\n      }\\n\\n      const url = this.api + \\\"/shared/v2/episode/list?_movieId=\\\" + movieId;\\n      const data = await this._fetchJSON(url);\\n\\n      if (!data || !data.status) {\\n        throw new Error(data && data.message ? data.message : \\\"Failed to fetch episodes\\\");\\n      }\\n\\n      let episodesArr = [];\\n      \\n      if (data && data.result) {\\n        const result = data.result;\\n        for (const key of Object.keys(result)) {\\n          if (Array.isArray(result[key])) {\\n            episodesArr = episodesArr.concat(result[key]);\\n          }\\n        }\\n      }\\n\\n      if (!Array.isArray(episodesArr) || episodesArr.length === 0) {\\n        throw new Error(\\\"No episodes found\\\");\\n      }\\n\\n      return episodesArr.map((ep) => ({\\n        id: movieId + \\\"/\\\" + lang + \\\"/\\\" + (ep.number || ep.episode || ep.id || 0),\\n        number: ep.number || ep.episode || ep.id || 0,\\n        title: ep.name_english || ep.title || ep.name || (\\\"Episode \\\" + (ep.number || ep.episode || ep.id || 0)),\\n        url: movieId + \\\"/\\\" + lang + \\\"/\\\" + (ep.number || ep.episode || ep.id || 0),\\n      }));\\n    } catch (e) {\\n      console.error(\\\"[findEpisodes] error:\\\", e && e.message ? e.message : e);\\n      throw new Error(e && e.message ? e.message : \\\"Failed to find episodes\\\");\\n    }\\n  }\\n\\n  async findEpisodeServer(episode, _server) {\\n    if (!_server) _server = \\\"AniCrush Server\\\";\\n    \\n    try {\\n      const urlParts = episode.url.split(\\\"/\\\");\\n      if (urlParts.length < 3) {\\n        throw new Error(\\\"Invalid episode URL format\\\");\\n      }\\n      \\n      const movieId = urlParts[0];\\n      const lang = urlParts[1];\\n      const episodeNum = urlParts[2];\\n\\n      console.log(\\\"[findEpisodeServer] Trying to find server for \\\" + movieId + \\\" episode \\\" + episodeNum + \\\" (\\\" + lang + \\\")\\\");\\n\\n      for (const serverId of this.availableServers) {\\n        try {\\n          const serverUrl = this.api + \\\"/shared/v2/episode/sources?_movieId=\\\" + movieId + \\\"&ep=\\\" + episodeNum + \\\"&sv=\\\" + serverId + \\\"&sc=\\\" + lang;\\n          console.log(\\\"[findEpisodeServer] Trying server \\\" + serverId + \\\": \\\" + serverUrl);\\n          \\n          const data = await this._fetchJSON(serverUrl);\\n\\n          if (!data || !data.status || !data.result) {\\n            console.log(\\\"[findEpisodeServer] Server \\\" + serverId + \\\" returned no valid result\\\");\\n            continue;\\n          }\\n\\n          const result = data.result;\\n\\n          if (result.type === \\\"error\\\") {\\n            console.log(\\\"[findEpisodeServer] Server \\\" + serverId + \\\" returned error type\\\");\\n            continue;\\n          }\\n\\n          if (result.type === \\\"iframe\\\" && result.link) {\\n            console.log(\\\"[findEpisodeServer] Server \\\" + serverId + \\\" returned iframe: \\\" + result.link);\\n            \\n            try {\\n              const extractedSources = await this._extractMegaCloudSources(result.link);\\n              \\n              if (extractedSources && extractedSources.length > 0) {\\n                console.log(\\\"[findEpisodeServer] Successfully extracted \\\" + extractedSources.length + \\\" direct sources from MegaCloud\\\");\\n                \\n                return {\\n                  provider: \\\"anicrush\\\",\\n                  server: _server + \\\" (Server \\\" + serverId + \\\")\\\",\\n                  headers: this.headers,\\n                  videoSources: extractedSources,\\n                };\\n              }\\n            } catch (extractError) {\\n              console.log(\\\"[findEpisodeServer] MegaCloud extraction failed:\\\", extractError && extractError.message ? extractError.message : extractError);\\n            }\\n            \\n            console.log(\\\"[findEpisodeServer] Falling back to iframe for server \\\" + serverId);\\n            \\n            return {\\n              provider: \\\"anicrush\\\",\\n              server: _server + \\\" (Server \\\" + serverId + \\\")\\\",\\n              headers: this.headers,\\n              videoSources: [{\\n                quality: \\\"auto\\\",\\n                url: result.link,\\n                type: \\\"iframe\\\",\\n                subtitles: [],\\n              }],\\n            };\\n          }\\n\\n          const sources = result && result.sources ? result.sources : [];\\n          const tracks = result && result.tracks ? result.tracks : [];\\n\\n          if (Array.isArray(sources) && sources.length > 0) {\\n            console.log(\\\"[findEpisodeServer] Server \\\" + serverId + \\\" returned \\\" + sources.length + \\\" direct sources\\\");\\n            \\n            const videoSources = sources\\n              .map((s) => {\\n                const cleanUrl = (s.file || s.url);\\n                if (cleanUrl) {\\n                  const trimmedUrl = cleanUrl.replace(/[\\\\r\\\\n]+/g, '').trim();\\n                  return {\\n                    quality: s.label || s.quality || \\\"auto\\\",\\n                    url: trimmedUrl,\\n                    type: s.type || (String(trimmedUrl).includes(\\\".m3u8\\\") ? \\\"m3u8\\\" : \\\"mp4\\\"),\\n                    subtitles: [],\\n                  };\\n                }\\n                return null;\\n              })\\n              .filter((v) => v && v.url);\\n\\n            const eng = Array.isArray(tracks)\\n              ? tracks.find((t) => (t.kind === \\\"captions\\\" || t.kind === \\\"subtitles\\\") && /english/i.test(t.label || \\\"\\\"))\\n              : null;\\n            if (eng && eng.file) {\\n              for (const vs of videoSources) {\\n                vs.subtitles = [{ url: eng.file, lang: eng.label || \\\"English\\\" }];\\n              }\\n            }\\n\\n            return {\\n              provider: \\\"anicrush\\\",\\n              server: _server + \\\" (Server \\\" + serverId + \\\")\\\",\\n              headers: this.headers,\\n              videoSources: videoSources,\\n            };\\n          }\\n\\n          console.log(\\\"[findEpisodeServer] Server \\\" + serverId + \\\" had no usable sources\\\");\\n        } catch (serverError) {\\n          console.log(\\\"[findEpisodeServer] Server \\\" + serverId + \\\" failed:\\\", serverError && serverError.message ? serverError.message : serverError);\\n          continue;\\n        }\\n      }\\n\\n      throw new Error(\\\"No working servers found for episode \\\" + episodeNum);\\n    } catch (e) {\\n      console.error(\\\"[findEpisodeServer] error:\\\", e && e.message ? e.message : e);\\n      throw new Error(e && e.message ? e.message : \\\"Failed to find episode server\\\");\\n    }\\n  }\\n\\n  async _fetchJSON(url) {\\n    const res = await fetch(url, {\\n      headers: this.headers,\\n    });\\n    \\n    if (!res.ok) {\\n      throw new Error(\\\"HTTP \\\" + res.status + \\\": \\\" + res.statusText);\\n    }\\n    \\n    return await res.json();\\n  }\\n\\n  async _extractMegaCloudSources(iframeUrl) {\\n    try {\\n      console.log(\\\"[_extractMegaCloudSources] Extracting from: \\\" + iframeUrl);\\n      \\n      const iframeResponse = await fetch(iframeUrl, {\\n        headers: {\\n          \\\"Accept\\\": \\\"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\\\",\\n          \\\"Referer\\\": this.base + \\\"/\\\",\\n          \\\"User-Agent\\\": this.headers[\\\"User-Agent\\\"],\\n        },\\n      });\\n\\n      if (!iframeResponse.ok) {\\n        throw new Error(\\\"Failed to fetch iframe: \\\" + iframeResponse.status);\\n      }\\n\\n      const iframeHtml = await iframeResponse.text();\\n      console.log(\\\"[_extractMegaCloudSources] Iframe HTML length: \\\" + iframeHtml.length);\\n\\n      const videoIdRegex = /\\\\/e-1\\\\/([^?]+)/;\\n      const videoIdMatch = iframeUrl.match(videoIdRegex);\\n      if (!videoIdMatch) {\\n        throw new Error(\\\"Could not extract video ID from iframe URL\\\");\\n      }\\n      \\n      const videoId = videoIdMatch[1];\\n      console.log(\\\"[_extractMegaCloudSources] Extracted video ID: \\\" + videoId);\\n\\n      let megaCloudApiUrl = \\\"https://megacloud.blog/ajax/embed-4/getSources?id=\\\" + videoId;\\n      console.log(\\\"[_extractMegaCloudSources] Using MegaCloud API URL: \\\" + megaCloudApiUrl);\\n\\n      const sourcesResponse = await fetch(megaCloudApiUrl, {\\n        headers: {\\n          \\\"Accept\\\": \\\"application/json, text/javascript, */*; q=0.01\\\",\\n          \\\"Referer\\\": iframeUrl,\\n          \\\"User-Agent\\\": this.headers[\\\"User-Agent\\\"],\\n          \\\"X-Requested-With\\\": \\\"XMLHttpRequest\\\",\\n        },\\n      });\\n\\n      console.log(\\\"[_extractMegaCloudSources] API response status: \\\" + sourcesResponse.status);\\n\\n      if (sourcesResponse.ok) {\\n        const sourcesData = await sourcesResponse.json();\\n        console.log(\\\"[_extractMegaCloudSources] MegaCloud API response:\\\", JSON.stringify(sourcesData).substring(0, 500));\\n        \\n        if (sourcesData.sources && Array.isArray(sourcesData.sources)) {\\n          const videoSources = sourcesData.sources.map((source) => {\\n            const cleanUrl = source.file ? source.file.replace(/[\\\\r\\\\n]+/g, '').trim() : null;\\n            \\n            if (cleanUrl) {\\n              return {\\n                quality: source.label || \\\"auto\\\",\\n                url: cleanUrl,\\n                type: cleanUrl && cleanUrl.includes(\\\".m3u8\\\") ? \\\"m3u8\\\" : \\\"mp4\\\",\\n                subtitles: [],\\n              };\\n            }\\n            return null;\\n          }).filter((vs) => vs && vs.url);\\n\\n          if (sourcesData.tracks && Array.isArray(sourcesData.tracks)) {\\n            const engSub = sourcesData.tracks.find((track) => \\n              track.kind === \\\"captions\\\" && /eng/i.test(track.label || \\\"\\\")\\n            );\\n            if (engSub && engSub.file) {\\n              videoSources.forEach(vs => {\\n                vs.subtitles = [{ url: engSub.file, lang: engSub.label || \\\"English\\\" }];\\n              });\\n            }\\n          }\\n\\n          if (videoSources.length > 0) {\\n            console.log(\\\"[_extractMegaCloudSources] Successfully extracted \\\" + videoSources.length + \\\" video sources from API\\\");\\n            return videoSources;\\n          }\\n        }\\n      }\\n\\n      throw new Error(\\\"No video sources found in MegaCloud iframe\\\");\\n    } catch (error) {\\n      console.error(\\\"[_extractMegaCloudSources] Error:\\\", error && error.message ? error.message : error);\\n      throw error;\\n    }\\n  }\\n}"
}