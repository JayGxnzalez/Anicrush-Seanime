{
  "id": "anicrush",
  "name": "AniCrush",
  "description": "AniCrush streaming provider (sub & dub) for Seanime",
  "version": "1.7.0",
  "author": "JayGxnzalez",
  "type": "onlinestream-provider",
  "language": "javascript",
  "payload": "class Provider {\n  constructor() {\n    this.api = \"https://api.anicrush.to\";\n    this.base = \"https://anicrush.to\";\n    this.availableServers = [4, 1, 3, 5, 6];\n    this.headers = {\n      \"Referer\": \"https://anicrush.to/\",\n      \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\"\n    };\n  }\n\n  getSettings() {\n    return {\n      episodeServers: [\"AniCrush Server\"],\n      supportsDub: true\n    };\n  }\n\n  async search(query) {\n    try {\n      const originalQuery = query.query;\n      const searchTerms = [originalQuery.toLowerCase()];\n      \n      if (originalQuery !== originalQuery.toLowerCase()) {\n        searchTerms.push(originalQuery);\n      }\n      \n      for (const searchTerm of searchTerms) {\n        try {\n          const q = encodeURIComponent(searchTerm);\n          const searchUrl = \"https://api.anicrush.to/shared/v2/movie/list?keyword=\" + q + \"&limit=24&page=1\";\n          const searchResponse = await this._fetchJSON(searchUrl);\n          \n          if (searchResponse.data && searchResponse.data.length > 0) {\n            const results = searchResponse.data.map(item => ({\n              id: item._id,\n              title: item.title,\n              url: \"https://anicrush.to/watch/\" + item.slug,\n              subOrDub: query.dubbed ? \"dub\" : \"sub\"\n            }));\n            return results;\n          }\n        } catch (error) {\n          continue;\n        }\n      }\n      \n      throw new Error(\"No results found\");\n    } catch (error) {\n      throw new Error(error.message);\n    }\n  }\n\n  async findEpisodes(id) {\n    try {\n      const idParts = id.split(\"/\");\n      const movieId = idParts[0];\n      const lang = (idParts[1] === \"dub\" || idParts[1] === \"sub\") ? idParts[1] : \"sub\";\n\n      if (!movieId || movieId.trim().length === 0) {\n        throw new Error(\"Invalid movieId\");\n      }\n\n      const url = this.api + \"/shared/v2/episode/list?_movieId=\" + movieId;\n      const data = await this._fetchJSON(url);\n\n      if (!data || !data.status) {\n        throw new Error(\"Failed to fetch episodes\");\n      }\n\n      let episodesArr = [];\n      \n      if (data && data.result) {\n        const result = data.result;\n        for (const key of Object.keys(result)) {\n          if (Array.isArray(result[key])) {\n            episodesArr = episodesArr.concat(result[key]);\n          }\n        }\n      }\n\n      if (!Array.isArray(episodesArr) || episodesArr.length === 0) {\n        throw new Error(\"No episodes found\");\n      }\n\n      return episodesArr.map((ep) => ({\n        id: movieId + \"/\" + lang + \"/\" + (ep.number || ep.episode || ep.id || 0),\n        number: ep.number || ep.episode || ep.id || 0,\n        title: ep.name_english || ep.title || ep.name || (\"Episode \" + (ep.number || ep.episode || ep.id || 0)),\n        url: movieId + \"/\" + lang + \"/\" + (ep.number || ep.episode || ep.id || 0)\n      }));\n    } catch (e) {\n      throw new Error(\"Failed to find episodes\");\n    }\n  }\n\n  async findEpisodeServer(episode, _server) {\n    if (!_server) _server = \"AniCrush Server\";\n    \n    try {\n      const urlParts = episode.url.split(\"/\");\n      if (urlParts.length < 3) {\n        throw new Error(\"Invalid episode URL format\");\n      }\n      \n      const movieId = urlParts[0];\n      const lang = urlParts[1];\n      const episodeNum = urlParts[2];\n\n      for (const serverId of this.availableServers) {\n        try {\n          const serverUrl = this.api + \"/shared/v2/episode/sources?_movieId=\" + movieId + \"&ep=\" + episodeNum + \"&sv=\" + serverId + \"&sc=\" + lang;\n          const data = await this._fetchJSON(serverUrl);\n\n          if (!data || !data.status || !data.result) {\n            continue;\n          }\n\n          const result = data.result;\n\n          if (result.type === \"error\") {\n            continue;\n          }\n\n          if (result.type === \"iframe\" && result.link) {\n            return {\n              provider: \"anicrush\",\n              server: _server + \" (Server \" + serverId + \")\",\n              headers: this.headers,\n              videoSources: [{\n                quality: \"auto\",\n                url: result.link,\n                type: \"iframe\",\n                subtitles: []\n              }]\n            };\n          }\n\n          const sources = result && result.sources ? result.sources : [];\n\n          if (Array.isArray(sources) && sources.length > 0) {\n            const videoSources = sources.map((s) => {\n              const cleanUrl = s.file || s.url;\n              if (cleanUrl) {\n                return {\n                  quality: s.label || s.quality || \"auto\",\n                  url: cleanUrl.trim(),\n                  type: s.type || (cleanUrl.includes(\".m3u8\") ? \"m3u8\" : \"mp4\"),\n                  subtitles: []\n                };\n              }\n              return null;\n            }).filter((v) => v && v.url);\n\n            return {\n              provider: \"anicrush\",\n              server: _server + \" (Server \" + serverId + \")\",\n              headers: this.headers,\n              videoSources: videoSources\n            };\n          }\n        } catch (serverError) {\n          continue;\n        }\n      }\n\n      throw new Error(\"No working servers found\");\n    } catch (e) {\n      throw new Error(\"Failed to find episode server\");\n    }\n  }\n\n  async _fetchJSON(url) {\n    const res = await fetch(url, {\n      headers: this.headers\n    });\n    \n    if (!res.ok) {\n      throw new Error(\"HTTP \" + res.status + \": \" + res.statusText);\n    }\n    \n    return await res.json();\n  }\n}"
}