{
  "id": "anicrush",
  "name": "AniCrush",
  "description": "AniCrush streaming provider (sub & dub) for Seanime",
  "version": "1.0.8",
  "author": "JayGxnzalez",
  "type": "onlinestream-provider",
  "language": "javascript",
  "lang": "en",
  "payload": "class Provider {\n  constructor() {\n    this.api = \"https://api.anicrush.to\";\n    this.base = \"https://anicrush.to\";\n    this.defaultServer = 4;\n  }\n\n  getSettings() {\n    return {\n      episodeServers: [\"AniCrush Server\"],\n      supportsDub: true,\n    };\n  }\n\n  async search(query) {\n    try {\n      const q = encodeURIComponent(query.query);\n      const url = `${this.api}/shared/v2/movie/list?keyword=${q}&limit=24&page=1`;\n\n      const data = await this._fetchJSON(url);\n      const movies = data?.result?.movies ?? data?.result ?? data?.movies ?? [];\n\n      if (!Array.isArray(movies) || movies.length === 0) return [];\n\n      const lang = query.dub ? \"dub\" : \"sub\";\n\n      return movies.map((m) => ({\n        id: `${m.id}/${lang}`,\n        title: m.name_english || m.name,\n        url: `${this.base}/watch/${m.slug}.${m.id}`,\n        subOrDub: lang,\n      }));\n    } catch (e) {\n      console.error(\"[search] error:\", e?.message ?? e);\n      return [];\n    }\n  }\n\n  async findEpisodes(id) {\n    try {\n      const idParts = id.split(\"/\");\n      const movieId = idParts[0];\n      const langPart = idParts[1];\n      const lang = (langPart === \"dub\" || langPart === \"sub\") ? langPart : \"sub\";\n\n      if (!movieId || movieId.trim().length === 0) {\n        console.error(\"[findEpisodes] Invalid movieId:\", movieId);\n        return [];\n      }\n\n      if (/^\\d+$/.test(movieId)) {\n        console.error(\"[findEpisodes] Received numeric ID which is not supported by AniCrush API:\", movieId);\n        console.error(\"[findEpisodes] Please ensure search results are using the correct alphanumeric movie IDs from AniCrush\");\n        return [];\n      }\n\n      const url = `${this.api}/shared/v2/episode/list?_movieId=${movieId}`;\n      const data = await this._fetchJSON(url);\n\n      if (!data?.status) {\n        console.error(\"[findEpisodes] API error for\", movieId, \":\", data?.message || \"Unknown error\");\n        return [];\n      }\n\n      let episodesArr = [];\n      \n      if (data?.result) {\n        const result = data.result;\n        for (const key of Object.keys(result)) {\n          if (Array.isArray(result[key])) {\n            episodesArr = episodesArr.concat(result[key]);\n          }\n        }\n      }\n\n      if (!Array.isArray(episodesArr) || episodesArr.length === 0) {\n        console.error(\"[findEpisodes] no episodes found for\", movieId, \"raw:\", JSON.stringify(data, null, 2));\n        return [];\n      }\n\n      return episodesArr.map((ep) => ({\n        id: `${movieId}/${lang}/${(ep.number ?? ep.episode ?? ep.id ?? 0)}`,\n        number: ep.number ?? ep.episode ?? ep.id ?? 0,\n        title: ep.name_english || ep.title || ep.name || `Episode ${ep.number ?? ep.episode ?? ep.id ?? 0}`,\n        url: `${this.api}/shared/v2/episode/sources?_movieId=${movieId}&ep=${ep.number ?? ep.episode ?? ep.id ?? 0}&sv=${this.defaultServer}&sc=${lang}`,\n      }));\n    } catch (e) {\n      console.error(\"[findEpisodes] error:\", e?.message ?? e);\n      return [];\n    }\n  }\n\n  async findEpisodeServer(episode, _server = \"AniCrush Server\") {\n    try {\n      const data = await this._fetchJSON(episode.url);\n\n      if (!data?.result) {\n        throw new Error(\"No result in API response\");\n      }\n\n      const result = data.result;\n\n      if (result.type === \"iframe\" && result.link) {\n        return {\n          provider: \"anicrush\",\n          server: _server,\n          headers: {\n            \"Accept\": \"application/json, text/plain, */*\",\n            \"Origin\": this.base,\n            \"Referer\": `${this.base}/`,\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n            \"x-site\": \"anicrush\",\n          },\n          videoSources: [{\n            quality: \"auto\",\n            url: result.link,\n            type: \"m3u8\",\n            subtitles: [],\n          }],\n        };\n      }\n\n      const sources = result?.sources ?? [];\n      const tracks = result?.tracks ?? [];\n\n      if (!Array.isArray(sources) || sources.length === 0) {\n        throw new Error(\"No video sources in response\");\n      }\n\n      const videoSources = sources\n        .map((s) => ({\n          quality: s.label || s.quality || \"auto\",\n          url: s.file || s.url,\n          type: s.type || (String(s.file || s.url).includes(\".m3u8\") ? \"m3u8\" : \"mp4\"),\n          subtitles: [],\n        }))\n        .filter((v) => !!v.url);\n\n      const eng = Array.isArray(tracks)\n        ? tracks.find((t) => (t.kind === \"captions\" || t.kind === \"subtitles\") && /english/i.test(t.label || \"\"))\n        : null;\n      if (eng?.file) {\n        for (const vs of videoSources) {\n          vs.subtitles = [{ url: eng.file, lang: eng.label || \"English\" }];\n        }\n      }\n\n      return {\n        provider: \"anicrush\",\n        server: _server,\n        headers: {\n          \"Accept\": \"application/json, text/plain, */*\",\n          \"Origin\": this.base,\n          \"Referer\": `${this.base}/`,\n          \"User-Agent\": \"Mozilla/5.0\",\n          \"x-site\": \"anicrush\",\n        },\n        videoSources,\n      };\n    } catch (e) {\n      console.error(\"[findEpisodeServer] error:\", e?.message ?? e);\n      return {\n        provider: \"anicrush\",\n        server: _server,\n        headers: {},\n        videoSources: [],\n      };\n    }\n  }\n\n  async _fetchJSON(url) {\n    const res = await fetch(url, {\n      headers: {\n        \"Accept\": \"application/json, text/plain, */*\",\n        \"Origin\": this.base,\n        \"Referer\": `${this.base}/`,\n        \"User-Agent\": \"Mozilla/5.0\",\n        \"x-site\": \"anicrush\",\n      },\n    });\n    return await res.json();\n  }\n}\n"
}
