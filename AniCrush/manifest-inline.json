{
  "id": "anicrush",
  "name": "AniCrush",
  "description": "AniCrush streaming provider (sub & dub) for Seanime",
  "version": "1.6.2",
  "author": "JayGxnzalez",
  "type": "onlinestream-provider",
  "language": "javascript",
  "payload": "class Provider {\\n  private api = \\\"https://api.anicrush.to\\\";\\n  private base = \\\"https://anicrush.to\\\";\\n  private availableServers = [4, 1, 3, 5, 6]; // Try multiple servers in order of preference\\n  \\n  // Simplified headers like GojoWtf\\n  private headers = {\\n    \\\"Referer\\\": \\\"https://anicrush.to/\\\",\\n    \\\"User-Agent\\\": \\\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\\\"\\n  };\\n\\n  getSettings() {\\n    return {\\n      episodeServers: [\\\"AniCrush Server\\\"],\\n      supportsDub: true,\\n    };\\n  }\\n\\n  async search(query) {\\n    try {\\n      const originalQuery = query.query;\\n      const searchTerms = [originalQuery];\\n      \\n      // Add variations for common title formats\\n      if (originalQuery.includes(\\\"THE ANIMATION\\\")) {\\n        searchTerms.push(originalQuery.replace(\\\" THE ANIMATION\\\", \\\"\\\"));\\n        searchTerms.push(originalQuery.replace(\\\"THE ANIMATION\\\", \\\"\\\"));\\n      }\\n      \\n      // Special handling for CITY THE ANIMATION\\n      if (originalQuery.toUpperCase().includes(\\\"CITY\\\")) {\\n        searchTerms.push(\\\"CITY\\\");\\n        searchTerms.push(\\\"City\\\");\\n        searchTerms.push(\\\"city\\\");\\n      }\\n      \\n      // Try each search term\\n      for (const searchTerm of searchTerms) {\\n        try {\\n          const q = encodeURIComponent(searchTerm.trim());\\n          const url = `${this.api}/shared/v2/movie/list?keyword=${q}&limit=24&page=1`;\\n\\n          const data = await this._fetchJSON(url);\\n          const movies = data?.result?.movies ?? data?.result ?? data?.movies ?? [];\\n\\n          if (Array.isArray(movies) && movies.length > 0) {\\n            const lang = query.dub ? \\\"dub\\\" : \\\"sub\\\";\\n\\n            const results = movies.map((m) => ({\\n              id: `${m.id}/${lang}`, // Use alphanumeric ID (correct format)\\n              title: m.name_english || m.name,\\n              url: `${this.base}/watch/${m.slug}.${m.id}`,\\n              subOrDub: lang,\\n            }));\\n            \\n            console.log(`[search] Found ${results.length} results for \\\"${searchTerm}\\\"`);\\n            return results;\\n          }\\n        } catch (searchError) {\\n          console.log(`[search] Failed to search for \\\"${searchTerm}\\\":`, searchError?.message ?? searchError);\\n          continue; // Try next search term\\n        }\\n      }\\n      \\n      // If no search terms worked\\n      throw new Error(\\\"No results found for any search variation\\\");\\n    } catch (e) {\\n      console.error(\\\"[search] error:\\\", e?.message ?? e);\\n      throw new Error(e?.message ?? \\\"Search failed\\\");\\n    }\\n  }\\n\\n  async findEpisodes(id) {\\n    try {\\n      // Handle both ID formats: \\\"movieId/lang\\\" and just \\\"movieId\\\"\\n      const idParts = id.split(\\\"/\\\");\\n      const movieId = idParts[0];\\n      const langPart = idParts[1];\\n      const lang = (langPart === \\\"dub\\\" || langPart === \\\"sub\\\") ? langPart : \\\"sub\\\";\\n\\n      // Validate movieId\\n      if (!movieId || movieId.trim().length === 0) {\\n        throw new Error(\\\"Invalid movieId\\\");\\n      }\\n\\n      // Check if we received a numeric ID (which indicates an issue with Seanime)\\n      if (/^\\\\d+$/.test(movieId)) {\\n        throw new Error(\\\"Received numeric ID which is not supported by AniCrush API\\\");\\n      }\\n\\n      const url = `${this.api}/shared/v2/episode/list?_movieId=${movieId}`;\\n      const data = await this._fetchJSON(url);\\n\\n      // Check if API returned an error\\n      if (!data?.status) {\\n        throw new Error(data?.message || \\\"Failed to fetch episodes\\\");\\n      }\\n\\n      // Handle new grouped episode structure\\n      let episodesArr[] = [];\\n      \\n      if (data?.result) {\\n        // Episodes are now grouped by ranges like \\\"001 - 100\\\", \\\"101 - 200\\\", etc.\\n        const result = data.result;\\n        for (const key of Object.keys(result)) {\\n          if (Array.isArray(result[key])) {\\n            episodesArr = episodesArr.concat(result[key]);\\n          }\\n        }\\n      }\\n\\n      if (!Array.isArray(episodesArr) || episodesArr.length === 0) {\\n        throw new Error(\\\"No episodes found\\\");\\n      }\\n\\n      return episodesArr.map((ep) => ({\\n        id: `${movieId}/${lang}/${(ep.number ?? ep.episode ?? ep.id ?? 0)}`,\\n        number: ep.number ?? ep.episode ?? ep.id ?? 0,\\n        title: ep.name_english || ep.title || ep.name || `Episode ${ep.number ?? ep.episode ?? ep.id ?? 0}`,\\n        url: `${movieId}/${lang}/${ep.number ?? ep.episode ?? ep.id ?? 0}`, // Store episode info for server fallback\\n      }));\\n    } catch (e) {\\n      console.error(\\\"[findEpisodes] error:\\\", e?.message ?? e);\\n      throw new Error(e?.message ?? \\\"Failed to find episodes\\\");\\n    }\\n  }\\n\\n  async findEpisodeServer(episode: EpisodeDetails, _server = \\\"AniCrush Server\\\") {\\n    try {\\n      // Parse episode URL to extract movieId, lang, and episode number\\n      const urlParts = episode.url.split(\\\"/\\\");\\n      if (urlParts.length < 3) {\\n        throw new Error(\\\"Invalid episode URL format\\\");\\n      }\\n      \\n      const movieId = urlParts[0];\\n      const lang = urlParts[1];\\n      const episodeNum = urlParts[2];\\n\\n      console.log(`[findEpisodeServer] Trying to find server for ${movieId} episode ${episodeNum} (${lang})`);\\n\\n      // Try multiple servers until we find one that works\\n      for (const serverId of this.availableServers) {\\n        try {\\n          const serverUrl = `${this.api}/shared/v2/episode/sources?_movieId=${movieId}&ep=${episodeNum}&sv=${serverId}&sc=${lang}`;\\n          console.log(`[findEpisodeServer] Trying server ${serverId}: ${serverUrl}`);\\n          \\n          const data = await this._fetchJSON(serverUrl);\\n\\n          if (!data?.status || !data?.result) {\\n            console.log(`[findEpisodeServer] Server ${serverId} returned no valid result`);\\n            continue;\\n          }\\n\\n          const result = data.result;\\n\\n          // Skip servers that return error type\\n          if (result.type === \\\"error\\\") {\\n            console.log(`[findEpisodeServer] Server ${serverId} returned error type`);\\n            continue;\\n          }\\n\\n          // Handle iframe type response (MegaCloud, etc.) - try to extract direct sources\\n          if (result.type === \\\"iframe\\\" && result.link) {\\n            console.log(`[findEpisodeServer] Server ${serverId} returned iframe: ${result.link}`);\\n            \\n            try {\\n              // Try to extract direct sources from MegaCloud\\n              const extractedSources = await this._extractMegaCloudSources(result.link);\\n              \\n              if (extractedSources && extractedSources.length > 0) {\\n                console.log(`[findEpisodeServer] Successfully extracted ${extractedSources.length} direct sources from MegaCloud`);\\n                \\n                return {\\n                  provider: \\\"anicrush\\\",\\n                  server: `${_server} (Server ${serverId})`,\\n                  headers: this.headers,\\n                  videoSources: extractedSources,\\n                };\\n              }\\n            } catch (extractError) {\\n              console.log(`[findEpisodeServer] MegaCloud extraction failed:`, extractError?.message ?? extractError);\\n            }\\n            \\n            // Fallback to iframe if extraction fails\\n            console.log(`[findEpisodeServer] Falling back to iframe for server ${serverId}`);\\n            \\n            return {\\n              provider: \\\"anicrush\\\",\\n              server: `${_server} (Server ${serverId})`,\\n              headers: this.headers,\\n              videoSources: [{\\n                quality: \\\"auto\\\",\\n                url: result.link,\\n                type: \\\"iframe\\\",\\n                subtitles: [],\\n              }],\\n            };\\n          }\\n\\n          // Handle direct sources (legacy support)\\n          const sources = result?.sources ?? [];\\n          const tracks = result?.tracks ?? [];\\n\\n          if (Array.isArray(sources) && sources.length > 0) {\\n            console.log(`[findEpisodeServer] Server ${serverId} returned ${sources.length} direct sources`);\\n            \\n            const videoSources = sources\\n              .map((s) => {\\n                // Clean URL like GojoWtf does\\n                const cleanUrl = (s.file || s.url)?.replace(/[\\\\r\\\\n]+/g, '').trim();\\n                \\n                return {\\n                  quality: s.label || s.quality || \\\"auto\\\",\\n                  url: cleanUrl,\\n                  type: s.type || (String(cleanUrl).includes(\\\".m3u8\\\") ? \\\"m3u8\\\" : \\\"mp4\\\"),\\n                  subtitles: [],\\n                };\\n              })\\n              .filter((v: VideoSource) => !!v.url);\\n\\n            // Try attach English subs\\n            const eng = Array.isArray(tracks)\\n              ? tracks.find((t) => (t.kind === \\\"captions\\\" || t.kind === \\\"subtitles\\\") && /english/i.test(t.label || \\\"\\\"))\\n              : null;\\n            if (eng?.file) {\\n              for (const vs of videoSources) {\\n                vs.subtitles = [{ url: eng.file, lang: eng.label || \\\"English\\\" }];\\n              }\\n            }\\n\\n            return {\\n              provider: \\\"anicrush\\\",\\n              server: `${_server} (Server ${serverId})`,\\n              headers: this.headers,\\n              videoSources,\\n            };\\n          }\\n\\n          console.log(`[findEpisodeServer] Server ${serverId} had no usable sources`);\\n        } catch (serverError) {\\n          console.log(`[findEpisodeServer] Server ${serverId} failed:`, serverError?.message ?? serverError);\\n          continue; // Try next server\\n        }\\n      }\\n\\n      // If all servers failed\\n      throw new Error(`No working servers found for episode ${episodeNum}`);\\n    } catch (e) {\\n      console.error(\\\"[findEpisodeServer] error:\\\", e?.message ?? e);\\n      throw new Error(e?.message ?? \\\"Failed to find episode server\\\");\\n    }\\n  }\\n\\n  private async _fetchJSON(url) {\\n    const res = await fetch(url, {\\n      headers: this.headers,\\n    });\\n    \\n    if (!res.ok) {\\n      throw new Error(`HTTP ${res.status}: ${res.statusText}`);\\n    }\\n    \\n    return await res.json();\\n  }\\n\\n  private async _extractMegaCloudSources(iframeUrl) {\\n    try {\\n      console.log(`[_extractMegaCloudSources] Extracting from: ${iframeUrl}`);\\n      \\n      // Fetch the iframe page\\n      const iframeResponse = await fetch(iframeUrl, {\\n        headers: {\\n          \\\"Accept\\\": \\\"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\\\",\\n          \\\"Referer\\\": this.base + \\\"/\\\",\\n          \\\"User-Agent\\\": this.headers[\\\"User-Agent\\\"],\\n        },\\n      });\\n\\n      if (!iframeResponse.ok) {\\n        throw new Error(`Failed to fetch iframe: ${iframeResponse.status}`);\\n      }\\n\\n      const iframeHtml = await iframeResponse.text();\\n      console.log(`[_extractMegaCloudSources] Iframe HTML length: ${iframeHtml.length}`);\\n\\n      // Extract the video ID from the iframe URL\\n      const videoIdMatch = iframeUrl.match(/\\\\/e-1\\\\/([^?]+)/);\\n      if (!videoIdMatch) {\\n        throw new Error(\\\"Could not extract video ID from iframe URL\\\");\\n      }\\n      \\n      const videoId = videoIdMatch[1];\\n      console.log(`[_extractMegaCloudSources] Extracted video ID: ${videoId}`);\\n\\n      // Try multiple patterns to find MegaCloud API endpoints\\n      const apiPatterns = [\\n        /ajax\\\\/embed-4\\\\/getSources\\\\?id=([^\\\"&\\\\s]+)/,\\n        /\\\\/ajax\\\\/embed-4\\\\/getSources\\\\?id=([^\\\"&\\\\s]+)/,\\n        /\\\"ajax\\\\/embed-4\\\\/getSources\\\\?id=([^\\\"&\\\\s]+)\\\"/,\\n        /getSources\\\\?id=([^\\\"&\\\\s]+)/,\\n        new RegExp(`getSources\\\\\\\\?id=${videoId.replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g, '\\\\\\\\$&')}`),\\n      ];\\n\\n      let megaCloudApiUrl = null;\\n      let extractedId = null;\\n\\n      for (const pattern of apiPatterns) {\\n        const match = iframeHtml.match(pattern);\\n        if (match) {\\n          extractedId = match[1] || videoId;\\n          megaCloudApiUrl = `https://megacloud.blog/ajax/embed-4/getSources?id=${extractedId}`;\\n          console.log(`[_extractMegaCloudSources] Found MegaCloud API URL: ${megaCloudApiUrl}`);\\n          break;\\n        }\\n      }\\n\\n      // If no pattern matched, try with the video ID from URL\\n      if (!megaCloudApiUrl) {\\n        megaCloudApiUrl = `https://megacloud.blog/ajax/embed-4/getSources?id=${videoId}`;\\n        console.log(`[_extractMegaCloudSources] Using video ID from URL: ${megaCloudApiUrl}`);\\n      }\\n\\n      // Try to call the MegaCloud API\\n      const sourcesResponse = await fetch(megaCloudApiUrl, {\\n        headers: {\\n          \\\"Accept\\\": \\\"application/json, text/javascript, */*; q=0.01\\\",\\n          \\\"Referer\\\": iframeUrl,\\n          \\\"User-Agent\\\": this.headers[\\\"User-Agent\\\"],\\n          \\\"X-Requested-With\\\": \\\"XMLHttpRequest\\\",\\n        },\\n      });\\n\\n      console.log(`[_extractMegaCloudSources] API response status: ${sourcesResponse.status}`);\\n\\n      if (sourcesResponse.ok) {\\n        const sourcesData = await sourcesResponse.json();\\n        console.log(`[_extractMegaCloudSources] MegaCloud API response:`, JSON.stringify(sourcesData).substring(0, 500));\\n        \\n        if (sourcesData.sources && Array.isArray(sourcesData.sources)) {\\n          const videoSources = sourcesData.sources.map((source) => {\\n            // Clean URL like GojoWtf does\\n            const cleanUrl = source.file?.replace(/[\\\\r\\\\n]+/g, '').trim();\\n            \\n            return {\\n              quality: source.label || \\\"auto\\\",\\n              url: cleanUrl,\\n              type: cleanUrl && cleanUrl.includes(\\\".m3u8\\\") ? \\\"m3u8\\\" : \\\"mp4\\\",\\n              subtitles: [],\\n            };\\n          }).filter((vs: VideoSource) => vs.url);\\n\\n          // Add subtitles if available\\n          if (sourcesData.tracks && Array.isArray(sourcesData.tracks)) {\\n            const engSub = sourcesData.tracks.find((track) => \\n              track.kind === \\\"captions\\\" && /eng/i.test(track.label || \\\"\\\")\\n            );\\n            if (engSub && engSub.file) {\\n              videoSources.forEach(vs => {\\n                vs.subtitles = [{ url: engSub.file, lang: engSub.label || \\\"English\\\" }];\\n              });\\n            }\\n          }\\n\\n          if (videoSources.length > 0) {\\n            console.log(`[_extractMegaCloudSources] Successfully extracted ${videoSources.length} video sources from API`);\\n            return videoSources;\\n          }\\n        }\\n      }\\n\\n      throw new Error(\\\"No video sources found in MegaCloud iframe\\\");\\n    } catch (error) {\\n      console.error(`[_extractMegaCloudSources] Error:`, error?.message ?? error);\\n      throw error; // Re-throw to allow fallback to iframe\\n    }\\n  }\\n}"
}