{
  "id": "anicrush",
  "name": "AniCrush",
  "description": "AniCrush streaming provider (sub & dub) for Seanime",
  "version": "1.5.0",
  "author": "JayGxnzalez",
  "type": "onlinestream-provider",
  "language": "javascript",
  "payload": "class Provider {\n  api = \"https://api.anicrush.to\";\n  base = \"https://anicrush.to\";\n  availableServers = [4, 1, 3, 5, 6]; // Try multiple servers in order of preference\n\n  getSettings() {\n    return {\n      episodeServers: [\"AniCrush Server\"],\n      supportsDub: true,\n    };\n  }\n\n  async search(query) {\n    try {\n      const q = encodeURIComponent(query.query);\n      const url = `${this.api}/shared/v2/movie/list?keyword=${q}&limit=24&page=1`;\n\n      const data = await this._fetchJSON(url);\n      const movies = data?.result?.movies ?? data?.result ?? data?.movies ?? [];\n\n      if (!Array.isArray(movies) || movies.length === 0) return [];\n\n      const lang = query.dub ? \"dub\" : \"sub\";\n\n      return movies.map((m) => ({\n        id: `${m.id}/${lang}`, // Use alphanumeric ID (correct format)\n        title: m.name_english || m.name,\n        url: `${this.base}/watch/${m.slug}.${m.id}`,\n        subOrDub: lang,\n      }));\n    } catch (e) {\n      console.error(\"[search] error:\", e?.message ?? e);\n      return [];\n    }\n  }\n\n  async findEpisodes(id) {\n    try {\n      // Handle both ID formats: \"movieId/lang\" and just \"movieId\"\n      const idParts = id.split(\"/\");\n      const movieId = idParts[0];\n      const langPart = idParts[1];\n      const lang = (langPart === \"dub\" || langPart === \"sub\") ? (langPart) : \"sub\";\n\n      // Validate movieId\n      if (!movieId || movieId.trim().length === 0) {\n        console.error(\"[findEpisodes] Invalid movieId:\", movieId);\n        return [];\n      }\n\n      // Check if we received a numeric ID (which indicates an issue with Seanime)\n      if (/^\\d+$/.test(movieId)) {\n        console.error(\"[findEpisodes] Received numeric ID which is not supported by AniCrush API:\", movieId);\n        console.error(\"[findEpisodes] Please ensure search results are using the correct alphanumeric movie IDs from AniCrush\");\n        return [];\n      }\n\n      const url = `${this.api}/shared/v2/episode/list?_movieId=${movieId}`;\n      const data = await this._fetchJSON(url);\n\n      // Check if API returned an error\n      if (!data?.status) {\n        console.error(\"[findEpisodes] API error for\", movieId, \":\", data?.message || \"Unknown error\");\n        return [];\n      }\n\n      // Handle new grouped episode structure\n      let episodesArr = [];\n      \n      if (data?.result) {\n        // Episodes are now grouped by ranges like \"001 - 100\", \"101 - 200\", etc.\n        const result = data.result;\n        for (const key of Object.keys(result)) {\n          if (Array.isArray(result[key])) {\n            episodesArr = episodesArr.concat(result[key]);\n          }\n        }\n      }\n\n      if (!Array.isArray(episodesArr) || episodesArr.length === 0) {\n        console.error(\"[findEpisodes] no episodes found for\", movieId, \"raw:\", JSON.stringify(data, null, 2));\n        return [];\n      }\n\n      return episodesArr.map((ep) => ({\n        id: `${movieId}/${lang}/${(ep.number ?? ep.episode ?? ep.id ?? 0)}`,\n        number: ep.number ?? ep.episode ?? ep.id ?? 0,\n        title: ep.name_english || ep.title || ep.name || `Episode ${ep.number ?? ep.episode ?? ep.id ?? 0}`,\n        url: `${movieId}/${lang}/${ep.number ?? ep.episode ?? ep.id ?? 0}`, // Store episode info for server fallback\n      }));\n    } catch (e) {\n      console.error(\"[findEpisodes] error:\", e?.message ?? e);\n      return [];\n    }\n  }\n\n  async findEpisodeServer(episode, _server = \"AniCrush Server\") {\n    try {\n      // Parse episode URL to extract movieId, lang, and episode number\n      const urlParts = episode.url.split(\"/\");\n      if (urlParts.length < 3) {\n        throw new Error(\"Invalid episode URL format\");\n      }\n      \n      const movieId = urlParts[0];\n      const lang = urlParts[1];\n      const episodeNum = urlParts[2];\n\n      console.log(`[findEpisodeServer] Trying to find server for ${movieId} episode ${episodeNum} (${lang})`);\n\n      // Try multiple servers until we find one that works\n      for (const serverId of this.availableServers) {\n        try {\n          const serverUrl = `${this.api}/shared/v2/episode/sources?_movieId=${movieId}&ep=${episodeNum}&sv=${serverId}&sc=${lang}`;\n          console.log(`[findEpisodeServer] Trying server ${serverId}: ${serverUrl}`);\n          \n          const data = await this._fetchJSON(serverUrl);\n\n          if (!data?.status || !data?.result) {\n            console.log(`[findEpisodeServer] Server ${serverId} returned no valid result`);\n            continue;\n          }\n\n          const result = data.result;\n\n          // Skip servers that return error type\n          if (result.type === \"error\") {\n            console.log(`[findEpisodeServer] Server ${serverId} returned error type`);\n            continue;\n          }\n\n          // Handle iframe type response (MegaCloud, etc.)\n          if (result.type === \"iframe\" && result.link) {\n            console.log(`[findEpisodeServer] Server ${serverId} returned iframe: ${result.link}`);\n            \n            // For now, let's try a simpler approach - return the iframe directly\n            // and let Seanime handle it through its proxy system\n            const videoSources = [{\n              quality: \"auto\",\n              url: result.link,\n              type: \"iframe\",\n              subtitles: [],\n            }];\n\n            console.log(`[findEpisodeServer] Returning iframe source for server ${serverId}`);\n            \n            return {\n              provider: \"anicrush\",\n              server: `${_server} (Server ${serverId})`,\n              headers: {\n                \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\",\n                \"Accept-Language\": \"en-US,en;q=0.9\",\n                \"Accept-Encoding\": \"gzip, deflate, br\",\n                \"Cache-Control\": \"no-cache\",\n                \"Pragma\": \"no-cache\",\n                \"Sec-Ch-Ua\": '\"Not_A Brand\";v=\"8\", \"Chromium\";v=\"120\", \"Google Chrome\";v=\"120\"',\n                \"Sec-Ch-Ua-Mobile\": \"?0\",\n                \"Sec-Ch-Ua-Platform\": '\"Windows\"',\n                \"Sec-Fetch-Dest\": \"iframe\",\n                \"Sec-Fetch-Mode\": \"navigate\",\n                \"Sec-Fetch-Site\": \"cross-site\",\n                \"Upgrade-Insecure-Requests\": \"1\",\n                \"Origin\": this.base,\n                \"Referer\": `${this.base}/`,\n                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n                \"x-site\": \"anicrush\",\n              },\n              videoSources,\n            };\n          }\n\n          // Handle direct sources (legacy support)\n          const sources = result?.sources ?? [];\n          const tracks = result?.tracks ?? [];\n\n          if (Array.isArray(sources) && sources.length > 0) {\n            console.log(`[findEpisodeServer] Server ${serverId} returned ${sources.length} direct sources`);\n            \n            const videoSources = sources\n              .map((s) => ({\n                quality: s.label || s.quality || \"auto\",\n                url: s.file || s.url,\n                type: s.type || (String(s.file || s.url).includes(\".m3u8\") ? \"m3u8\" : \"mp4\"),\n                subtitles: [],\n              }))\n              .filter((v) => !!v.url);\n\n            // Try attach English subs\n            const eng = Array.isArray(tracks)\n              ? tracks.find((t) => (t.kind === \"captions\" || t.kind === \"subtitles\") && /english/i.test(t.label || \"\"))\n              : null;\n            if (eng?.file) {\n              for (const vs of videoSources) {\n                vs.subtitles = [{ url: eng.file, lang: eng.label || \"English\" }];\n              }\n            }\n\n            return {\n              provider: \"anicrush\",\n              server: `${_server} (Server ${serverId})`,\n              headers: {\n                \"Accept\": \"application/json, text/plain, */*\",\n                \"Origin\": this.base,\n                \"Referer\": `${this.base}/`,\n                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n                \"x-site\": \"anicrush\",\n              },\n              videoSources,\n            };\n          }\n\n          console.log(`[findEpisodeServer] Server ${serverId} had no usable sources`);\n        } catch (serverError) {\n          console.log(`[findEpisodeServer] Server ${serverId} failed:`, serverError?.message ?? serverError);\n          continue; // Try next server\n        }\n      }\n\n      // If all servers failed\n      throw new Error(`No working servers found for episode ${episodeNum}`);\n    } catch (e) {\n      console.error(\"[findEpisodeServer] error:\", e?.message ?? e);\n      return {\n        provider: \"anicrush\",\n        server: _server,\n        headers: {},\n        videoSources: [],\n      };\n    }\n  }\n\n  async _fetchJSON(url) {\n    // Small delay to avoid triggering rate limits\n    await new Promise(resolve => setTimeout(resolve, 100));\n    \n    const res = await fetch(url, {\n      headers: {\n        \"Accept\": \"application/json, text/plain, */*\",\n        \"Accept-Language\": \"en-US,en;q=0.9\",\n        \"Accept-Encoding\": \"gzip, deflate, br\",\n        \"Cache-Control\": \"no-cache\",\n        \"Pragma\": \"no-cache\",\n        \"Sec-Ch-Ua\": '\"Not_A Brand\";v=\"8\", \"Chromium\";v=\"120\", \"Google Chrome\";v=\"120\"',\n        \"Sec-Ch-Ua-Mobile\": \"?0\",\n        \"Sec-Ch-Ua-Platform\": '\"Windows\"',\n        \"Sec-Fetch-Dest\": \"empty\",\n        \"Sec-Fetch-Mode\": \"cors\",\n        \"Sec-Fetch-Site\": \"same-origin\",\n        \"Origin\": this.base,\n        \"Referer\": `${this.base}/`,\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n        \"x-site\": \"anicrush\",\n      },\n    });\n    return await res.json();\n  }\n\n  async _extractMegaCloudSources(iframeUrl) {\n    try {\n      console.log(`[_extractMegaCloudSources] Extracting from: ${iframeUrl}`);\n      \n      // Fetch the iframe page\n      const iframeResponse = await fetch(iframeUrl, {\n        headers: {\n          \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\",\n          \"Accept-Language\": \"en-US,en;q=0.5\",\n          \"Accept-Encoding\": \"gzip, deflate, br\",\n          \"Referer\": this.base + \"/\",\n          \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n        },\n      });\n\n      if (!iframeResponse.ok) {\n        throw new Error(`Failed to fetch iframe: ${iframeResponse.status}`);\n      }\n\n      const iframeHtml = await iframeResponse.text();\n      console.log(`[_extractMegaCloudSources] Iframe HTML length: ${iframeHtml.length}`);\n\n      // Extract the video ID from the iframe URL\n      const videoIdMatch = iframeUrl.match(/\\/e-1\\/([^?]+)/);\n      if (!videoIdMatch) {\n        throw new Error(\"Could not extract video ID from iframe URL\");\n      }\n      \n      const videoId = videoIdMatch[1];\n      console.log(`[_extractMegaCloudSources] Extracted video ID: ${videoId}`);\n\n      // Try multiple patterns to find MegaCloud API endpoints\n      const apiPatterns = [\n        /ajax\\/embed-4\\/getSources\\?id=([^\"&\\s]+)/,\n        /\\/ajax\\/embed-4\\/getSources\\?id=([^\"&\\s]+)/,\n        /\"ajax\\/embed-4\\/getSources\\?id=([^\"&\\s]+)\"/,\n        /getSources\\?id=([^\"&\\s]+)/,\n        // Try with the extracted video ID directly\n        new RegExp(`getSources\\\\?id=${videoId.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}`),\n      ];\n\n      let megaCloudApiUrl = null;\n      let extractedId = null;\n\n      for (const pattern of apiPatterns) {\n        const match = iframeHtml.match(pattern);\n        if (match) {\n          extractedId = match[1] || videoId;\n          megaCloudApiUrl = `https://megacloud.blog/ajax/embed-4/getSources?id=${extractedId}`;\n          console.log(`[_extractMegaCloudSources] Found MegaCloud API URL with pattern: ${megaCloudApiUrl}`);\n          break;\n        }\n      }\n\n      // If no pattern matched, try with the video ID from URL\n      if (!megaCloudApiUrl) {\n        megaCloudApiUrl = `https://megacloud.blog/ajax/embed-4/getSources?id=${videoId}`;\n        console.log(`[_extractMegaCloudSources] Using video ID from URL: ${megaCloudApiUrl}`);\n      }\n\n      // Try to call the MegaCloud API\n      try {\n        const sourcesResponse = await fetch(megaCloudApiUrl, {\n          headers: {\n            \"Accept\": \"application/json, text/javascript, */*; q=0.01\",\n            \"Referer\": iframeUrl,\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n            \"X-Requested-With\": \"XMLHttpRequest\",\n          },\n        });\n\n        console.log(`[_extractMegaCloudSources] API response status: ${sourcesResponse.status}`);\n\n        if (sourcesResponse.ok) {\n          const sourcesData = await sourcesResponse.json();\n          console.log(`[_extractMegaCloudSources] MegaCloud API response:`, JSON.stringify(sourcesData).substring(0, 500));\n          \n          if (sourcesData.sources && Array.isArray(sourcesData.sources)) {\n            const videoSources = sourcesData.sources.map((source) => ({\n              quality: source.label || \"auto\",\n              url: source.file,\n              type: source.file && source.file.includes(\".m3u8\") ? \"m3u8\" : \"mp4\",\n              subtitles: [],\n            })).filter((vs) => vs.url);\n\n            // Add subtitles if available\n            if (sourcesData.tracks && Array.isArray(sourcesData.tracks)) {\n              const engSub = sourcesData.tracks.find((track) => \n                track.kind === \"captions\" && /eng/i.test(track.label || \"\")\n              );\n              if (engSub && engSub.file) {\n                videoSources.forEach(vs => {\n                  vs.subtitles = [{ url: engSub.file, lang: engSub.label || \"English\" }];\n                });\n              }\n            }\n\n            if (videoSources.length > 0) {\n              console.log(`[_extractMegaCloudSources] Successfully extracted ${videoSources.length} video sources from API`);\n              return videoSources;\n            }\n          }\n        } else {\n          console.log(`[_extractMegaCloudSources] API call failed with status: ${sourcesResponse.status}`);\n        }\n      } catch (apiError) {\n        console.log(`[_extractMegaCloudSources] API call error:`, apiError?.message ?? apiError);\n      }\n\n      // Fallback 1: Look for direct video URLs in the HTML with various patterns\n      console.log(`[_extractMegaCloudSources] Trying HTML parsing fallbacks...`);\n      \n      const videoPatterns = [\n        /file\\s*:\\s*\"([^\"]*\\.m3u8[^\"]*)\"/,\n        /\"file\"\\s*:\\s*\"([^\"]*\\.m3u8[^\"]*)\"/,\n        /source\\s*:\\s*\"([^\"]*\\.m3u8[^\"]*)\"/,\n        /\"source\"\\s*:\\s*\"([^\"]*\\.m3u8[^\"]*)\"/,\n        /src\\s*:\\s*\"([^\"]*\\.m3u8[^\"]*)\"/,\n        /\"src\"\\s*:\\s*\"([^\"]*\\.m3u8[^\"]*)\"/,\n        /file\\s*:\\s*\"([^\"]*\\.mp4[^\"]*)\"/,\n        /\"file\"\\s*:\\s*\"([^\"]*\\.mp4[^\"]*)\"/,\n        /source\\s*:\\s*\"([^\"]*\\.mp4[^\"]*)\"/,\n        /\"source\"\\s*:\\s*\"([^\"]*\\.mp4[^\"]*)\"/,\n        /src\\s*:\\s*\"([^\"]*\\.mp4[^\"]*)\"/,\n        /\"src\"\\s*:\\s*\"([^\"]*\\.mp4[^\"]*)\"/,\n      ];\n\n      for (const pattern of videoPatterns) {\n        const match = iframeHtml.match(pattern);\n        if (match && match[1]) {\n          const videoUrl = match[1];\n          const videoType = videoUrl.includes(\".m3u8\") ? \"m3u8\" : \"mp4\";\n          console.log(`[_extractMegaCloudSources] Found ${videoType.toUpperCase()} URL in HTML: ${videoUrl}`);\n          \n          return [{\n            quality: \"auto\",\n            url: videoUrl,\n            type: videoType,\n            subtitles: [],\n          }];\n        }\n      }\n\n      // Fallback 2: Look for any HTTP/HTTPS URLs that might be video streams\n      console.log(`[_extractMegaCloudSources] Trying generic URL patterns...`);\n      \n      const genericPatterns = [\n        /https?:\\/\\/[^\"\\s]+\\.m3u8[^\"\\s]*/g,\n        /https?:\\/\\/[^\"\\s]+\\.mp4[^\"\\s]*/g,\n      ];\n\n      for (const pattern of genericPatterns) {\n        const matches = iframeHtml.match(pattern);\n        if (matches && matches.length > 0) {\n          const videoUrl = matches[0];\n          const videoType = videoUrl.includes(\".m3u8\") ? \"m3u8\" : \"mp4\";\n          console.log(`[_extractMegaCloudSources] Found generic ${videoType.toUpperCase()} URL: ${videoUrl}`);\n          \n          return [{\n            quality: \"auto\",\n            url: videoUrl,\n            type: videoType,\n            subtitles: [],\n          }];\n        }\n      }\n\n      // Log a sample of the HTML for debugging\n      console.log(`[_extractMegaCloudSources] HTML sample (first 1000 chars):`, iframeHtml.substring(0, 1000));\n      console.log(`[_extractMegaCloudSources] HTML sample (last 1000 chars):`, iframeHtml.substring(Math.max(0, iframeHtml.length - 1000)));\n\n      throw new Error(\"No video sources found in MegaCloud iframe\");\n    } catch (error) {\n      console.error(`[_extractMegaCloudSources] Error:`, error?.message ?? error);\n      return [];\n    }\n  }\n}\n"
}