{
  "id": "anicrush",
  "name": "AniCrush",
  "description": "AniCrush streaming provider (sub & dub) for Seanime",
  "version": "1.0.4",
  "author": "JayGxnzalez",
  "type": "onlinestream-provider",
  "language": "javascript",
  "lang": "en",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n\nclass Provider {\n  private api = \"https://api.anicrush.to\";\n  private base = \"https://anicrush.to\";\n  private defaultServer = 4;\n\n  getSettings(): Settings {\n    return {\n      episodeServers: [\"AniCrush Server\"],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    try {\n      const q = encodeURIComponent(query.query);\n      const url = `${this.api}/shared/v2/movie/list?keyword=${q}&limit=24&page=1`;\n\n      const data = await this._fetchJSON(url);\n      const movies = data?.result?.movies ?? data?.result ?? data?.movies ?? [];\n\n      if (!Array.isArray(movies) || movies.length === 0) return [];\n\n      const lang: SubOrDub = query.dub ? \"dub\" : \"sub\";\n\n      return movies.map((m: any) => ({\n        id: `${m.id}/${lang}`,\n        title: m.name_english || m.name,\n        url: `${this.base}/watch/${m.slug}.${m.id}`,\n        subOrDub: lang,\n      }));\n    } catch (e: any) {\n      console.error(\"[search] error:\", e?.message ?? e);\n      return [];\n    }\n  }\n\n  async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n    try {\n      const [movieId, langPart] = id.split(\"/\");\n      const lang: \"dub\" | \"sub\" = (langPart === \"dub\" || langPart === \"sub\") ? (langPart as any) : \"sub\";\n\n      const url = `${this.api}/shared/v2/episode/list?_movieId=${movieId}`;\n      const data = await this._fetchJSON(url);\n\n      // Handle new grouped episode structure\n      let episodesArr: any[] = [];\n      \n      if (data?.result) {\n        // Episodes are now grouped by ranges like \"001 - 100\", \"101 - 200\", etc.\n        const result = data.result;\n        for (const key of Object.keys(result)) {\n          if (Array.isArray(result[key])) {\n            episodesArr = episodesArr.concat(result[key]);\n          }\n        }\n      }\n\n      if (!Array.isArray(episodesArr) || episodesArr.length === 0) {\n        console.error(\"[findEpisodes] no episodes found for\", movieId, \"raw:\", JSON.stringify(data, null, 2));\n        return [];\n      }\n\n      return episodesArr.map((ep: any) => ({\n        id: `${movieId}/${lang}/${(ep.number ?? ep.episode ?? ep.id ?? 0)}`,\n        number: ep.number ?? ep.episode ?? ep.id ?? 0,\n        title: ep.name_english || ep.title || ep.name || `Episode ${ep.number ?? ep.episode ?? ep.id ?? 0}`,\n        url: `${this.api}/shared/v2/episode/sources?_movieId=${movieId}&ep=${ep.number ?? ep.episode ?? ep.id ?? 0}&sv=${this.defaultServer}&sc=${lang}`,\n      }));\n    } catch (e: any) {\n      console.error(\"[findEpisodes] error:\", e?.message ?? e);\n      return [];\n    }\n  }\n\n  async findEpisodeServer(episode: EpisodeDetails, _server: string = \"AniCrush Server\"): Promise<EpisodeServer> {\n    try {\n      const data = await this._fetchJSON(episode.url);\n\n      if (!data?.result) {\n        throw new Error(\"No result in API response\");\n      }\n\n      const result = data.result;\n\n      // Handle iframe type response\n      if (result.type === \"iframe\" && result.link) {\n        // For iframe sources, we need to extract the actual video URL\n        // This might require additional processing depending on the iframe provider\n        return {\n          provider: \"anicrush\",\n          server: _server,\n          headers: {\n            \"Accept\": \"application/json, text/plain, */*\",\n            \"Origin\": this.base,\n            \"Referer\": `${this.base}/`,\n            \"User-Agent\": \"Mozilla/5.0\",\n            \"x-site\": \"anicrush\",\n          },\n          videoSources: [{\n            quality: \"auto\",\n            url: result.link,\n            type: \"iframe\",\n            subtitles: [],\n          }],\n        };\n      }\n\n      // Handle direct sources (legacy support)\n      const sources = result?.sources ?? [];\n      const tracks = result?.tracks ?? [];\n\n      if (!Array.isArray(sources) || sources.length === 0) {\n        throw new Error(\"No video sources in response\");\n      }\n\n      const videoSources: VideoSource[] = sources\n        .map((s: any) => ({\n          quality: s.label || s.quality || \"auto\",\n          url: s.file || s.url,\n          type: s.type || (String(s.file || s.url).includes(\".m3u8\") ? \"m3u8\" : \"mp4\"),\n          subtitles: [],\n        }))\n        .filter((v: any) => !!v.url);\n\n      // Try attach English subs\n      const eng = Array.isArray(tracks)\n        ? tracks.find((t: any) => (t.kind === \"captions\" || t.kind === \"subtitles\") && /english/i.test(t.label || \"\"))\n        : null;\n      if (eng?.file) {\n        for (const vs of videoSources) {\n          vs.subtitles = [{ url: eng.file, lang: eng.label || \"English\" }];\n        }\n      }\n\n      return {\n        provider: \"anicrush\",\n        server: _server,\n        headers: {\n          \"Accept\": \"application/json, text/plain, */*\",\n          \"Origin\": this.base,\n          \"Referer\": `${this.base}/`,\n          \"User-Agent\": \"Mozilla/5.0\",\n          \"x-site\": \"anicrush\",\n        },\n        videoSources,\n      };\n    } catch (e: any) {\n      console.error(\"[findEpisodeServer] error:\", e?.message ?? e);\n      return {\n        provider: \"anicrush\",\n        server: _server,\n        headers: {},\n        videoSources: [],\n      };\n    }\n  }\n\n  private async _fetchJSON(url: string): Promise<any> {\n    const res = await fetch(url, {\n      headers: {\n        \"Accept\": \"application/json, text/plain, */*\",\n        \"Origin\": this.base,\n        \"Referer\": `${this.base}/`,\n        \"User-Agent\": \"Mozilla/5.0\",\n        \"x-site\": \"anicrush\",\n      },\n    });\n    return await res.json();\n  }\n}\n"
}